METHOD: System.Void VSharp.Test.Tests.ListWorking.TestItemLast(VSharp.Test.Tests.ListNode)
RESULT: <VOID>
HEAP:
{ heap = merge[
	(!(0 == l) & !(0 == μ[Length]_1) & 0 == l.VSharp.Test.Tests.ListNode.Next, { heap = { heap = <empty>, statics = merge[
	(0 == l | 0 == l.VSharp.Test.Tests.ListNode.Next, s0),
	(!(0 == l) & !(0 == l.VSharp.Test.Tests.ListNode.Next), write({ heap = <empty>, statics = s0 } ⚪ recapp(Last), s1))] } ⚪ recapp(Length), statics = merge[
	(!(0 == l) & 0 == l.VSharp.Test.Tests.ListNode.Next, write({ heap = merge[
	(0 == l | 0 == l.VSharp.Test.Tests.ListNode.Next, <empty>),
	(!(0 == l) & !(0 == l.VSharp.Test.Tests.ListNode.Next), { heap = <empty>, statics = s0 } ⚪ recapp(Last))], statics = s0 } ⚪ recapp(Length), s1)),
	(!(0 == l) & !(0 == l.VSharp.Test.Tests.ListNode.Next), write({ heap = merge[
	(0 == l | 0 == l.VSharp.Test.Tests.ListNode.Next, <empty>),
	(!(0 == l) & !(0 == l.VSharp.Test.Tests.ListNode.Next), { heap = <empty>, statics = s0 } ⚪ recapp(Last))], statics = write({ heap = <empty>, statics = s0 } ⚪ recapp(Last), s1) } ⚪ recapp(Length), s1)),
	(0 == l, s0)] } ⚪ recapp(Item)),
	(!(0 == l) & 0 == l.VSharp.Test.Tests.ListNode.Next & 0 == μ[Length]_1, { heap = <empty>, statics = merge[
	(0 == l | 0 == l.VSharp.Test.Tests.ListNode.Next, s0),
	(!(0 == l) & !(0 == l.VSharp.Test.Tests.ListNode.Next), write({ heap = <empty>, statics = s0 } ⚪ recapp(Last), s1))] } ⚪ recapp(Length)),
	(!(0 == l) & !(0 == l.VSharp.Test.Tests.ListNode.Next) & !(0 == μ[Length]_1), { heap = { heap = { heap = <empty>, statics = s0 } ⚪ recapp(Last), statics = merge[
	(0 == l | 0 == l.VSharp.Test.Tests.ListNode.Next, s0),
	(!(0 == l) & !(0 == l.VSharp.Test.Tests.ListNode.Next), write({ heap = <empty>, statics = s0 } ⚪ recapp(Last), s1))] } ⚪ recapp(Length), statics = merge[
	(!(0 == l) & 0 == l.VSharp.Test.Tests.ListNode.Next, write({ heap = merge[
	(0 == l | 0 == l.VSharp.Test.Tests.ListNode.Next, <empty>),
	(!(0 == l) & !(0 == l.VSharp.Test.Tests.ListNode.Next), { heap = <empty>, statics = s0 } ⚪ recapp(Last))], statics = s0 } ⚪ recapp(Length), s1)),
	(!(0 == l) & !(0 == l.VSharp.Test.Tests.ListNode.Next), write({ heap = merge[
	(0 == l | 0 == l.VSharp.Test.Tests.ListNode.Next, <empty>),
	(!(0 == l) & !(0 == l.VSharp.Test.Tests.ListNode.Next), { heap = <empty>, statics = s0 } ⚪ recapp(Last))], statics = write({ heap = <empty>, statics = s0 } ⚪ recapp(Last), s1) } ⚪ recapp(Length), s1)),
	(0 == l, s0)] } ⚪ recapp(Item)),
	(!(0 == l) & !(0 == l.VSharp.Test.Tests.ListNode.Next) & 0 == μ[Length]_1, { heap = { heap = <empty>, statics = s0 } ⚪ recapp(Last), statics = merge[
	(0 == l | 0 == l.VSharp.Test.Tests.ListNode.Next, s0),
	(!(0 == l) & !(0 == l.VSharp.Test.Tests.ListNode.Next), write({ heap = <empty>, statics = s0 } ⚪ recapp(Last), s1))] } ⚪ recapp(Length)),
	(0 == l, <empty>)], statics = merge[
	(!(0 == l) & !(0 == μ[Length]_1) & 0 == l.VSharp.Test.Tests.ListNode.Next, { heap = merge[
	(!(0 == l) & 0 == l.VSharp.Test.Tests.ListNode.Next, { heap = <empty>, statics = merge[
	(0 == l | 0 == l.VSharp.Test.Tests.ListNode.Next, s0),
	(!(0 == l) & !(0 == l.VSharp.Test.Tests.ListNode.Next), write({ heap = <empty>, statics = s0 } ⚪ recapp(Last), s1))] } ⚪ recapp(Length)),
	(!(0 == l) & !(0 == l.VSharp.Test.Tests.ListNode.Next), { heap = { heap = <empty>, statics = s0 } ⚪ recapp(Last), statics = merge[
	(0 == l | 0 == l.VSharp.Test.Tests.ListNode.Next, s0),
	(!(0 == l) & !(0 == l.VSharp.Test.Tests.ListNode.Next), write({ heap = <empty>, statics = s0 } ⚪ recapp(Last), s1))] } ⚪ recapp(Length)),
	(0 == l, <empty>)], statics = write({ heap = merge[
	(0 == l | 0 == l.VSharp.Test.Tests.ListNode.Next, <empty>),
	(!(0 == l) & !(0 == l.VSharp.Test.Tests.ListNode.Next), { heap = <empty>, statics = s0 } ⚪ recapp(Last))], statics = s0 } ⚪ recapp(Length), s1) } ⚪ recapp(Item)),
	(!(0 == l) & 0 == l.VSharp.Test.Tests.ListNode.Next & 0 == μ[Length]_1, write({ heap = merge[
	(0 == l | 0 == l.VSharp.Test.Tests.ListNode.Next, <empty>),
	(!(0 == l) & !(0 == l.VSharp.Test.Tests.ListNode.Next), { heap = <empty>, statics = s0 } ⚪ recapp(Last))], statics = s0 } ⚪ recapp(Length), s1)),
	(!(0 == l) & !(0 == l.VSharp.Test.Tests.ListNode.Next) & !(0 == μ[Length]_1), { heap = merge[
	(!(0 == l) & 0 == l.VSharp.Test.Tests.ListNode.Next, { heap = <empty>, statics = merge[
	(0 == l | 0 == l.VSharp.Test.Tests.ListNode.Next, s0),
	(!(0 == l) & !(0 == l.VSharp.Test.Tests.ListNode.Next), write({ heap = <empty>, statics = s0 } ⚪ recapp(Last), s1))] } ⚪ recapp(Length)),
	(!(0 == l) & !(0 == l.VSharp.Test.Tests.ListNode.Next), { heap = { heap = <empty>, statics = s0 } ⚪ recapp(Last), statics = merge[
	(0 == l | 0 == l.VSharp.Test.Tests.ListNode.Next, s0),
	(!(0 == l) & !(0 == l.VSharp.Test.Tests.ListNode.Next), write({ heap = <empty>, statics = s0 } ⚪ recapp(Last), s1))] } ⚪ recapp(Length)),
	(0 == l, <empty>)], statics = write({ heap = merge[
	(0 == l | 0 == l.VSharp.Test.Tests.ListNode.Next, <empty>),
	(!(0 == l) & !(0 == l.VSharp.Test.Tests.ListNode.Next), { heap = <empty>, statics = s0 } ⚪ recapp(Last))], statics = write({ heap = <empty>, statics = s0 } ⚪ recapp(Last), s1) } ⚪ recapp(Length), s1) } ⚪ recapp(Item)),
	(!(0 == l) & !(0 == l.VSharp.Test.Tests.ListNode.Next) & 0 == μ[Length]_1, write({ heap = merge[
	(0 == l | 0 == l.VSharp.Test.Tests.ListNode.Next, <empty>),
	(!(0 == l) & !(0 == l.VSharp.Test.Tests.ListNode.Next), { heap = <empty>, statics = s0 } ⚪ recapp(Last))], statics = write({ heap = <empty>, statics = s0 } ⚪ recapp(Last), s1) } ⚪ recapp(Length), s1)),
	(0 == l, s0)] } where
---------- s0 = ----------
VSharp.Test.Tests.ListWorking ==> STRUCT VSharp.Test.Tests.ListWorking[]
VSharp.Test.Tests.SharedList ==> STRUCT VSharp.Test.Tests.SharedList[]
---------- s1 = ----------
VSharp.Test.Tests.ListNode ==> STRUCT VSharp.Test.Tests.ListNode[]
VSharp.Test.Tests.SharedList ==> STRUCT VSharp.Test.Tests.SharedList[]
