METHOD: System.Single VSharp.Test.Tests.Arithmetics.AbsSingleMethod()
RESULT: 5.9
HEAP:
{ heap = h0, statics = s1 } where
---------- h0 = ----------
1 ==> [| 0 ~> System.Empty; 1 ~> System.Object; 2 ~> System.DBNull; 3 ~> System.Boolean; 4 ~> System.Char; 5 ~> System.SByte; 6 ~> System.Byte; 7 ~> System.Int16; 8 ~> System.UInt16; 9 ~> System.Int32; 10 ~> System.UInt32; 11 ~> System.Int64; 12 ~> System.UInt64; 13 ~> System.Single; 14 ~> System.Double; 15 ~> System.Decimal; 16 ~> System.DateTime; 17 ~> System.Object; 18 ~> System.String ... 19 ... |]
2 ==> System.__Filters CLASS []
3 ==> <Lambda Expression System.Reflection.MemberFilter>
4 ==> <Lambda Expression System.Reflection.MemberFilter>
5 ==> <Lambda Expression System.Reflection.MemberFilter>
6 ==> System.Reflection.Missing CLASS []
7 ==> [|... 0 ... |]
8 ==> [| 0 ~> 'A'; 1 ~> 'B'; 2 ~> 'C'; 3 ~> 'D'; 4 ~> 'E'; 5 ~> 'F'; 6 ~> 'G'; 7 ~> 'H'; 8 ~> 'I'; 9 ~> 'J'; 10 ~> 'K'; 11 ~> 'L'; 12 ~> 'M'; 13 ~> 'N'; 14 ~> 'O'; 15 ~> 'P'; 16 ~> 'Q'; 17 ~> 'R'; 18 ~> 'S'; 19 ~> 'T'; 20 ~> 'U'; 21 ~> 'V'; 22 ~> 'W'; 23 ~> 'X'; 24 ~> 'Y'; 25 ~> 'Z'; 26 ~> 'a'; 27 ~> 'b'; 28 ~> 'c'; 29 ~> 'd'; 30 ~> 'e'; 31 ~> 'f'; 32 ~> 'g'; 33 ~> 'h'; 34 ~> 'i'; 35 ~> 'j'; 36 ~> 'k'; 37 ~> 'l'; 38 ~> 'm'; 39 ~> 'n'; 40 ~> 'o'; 41 ~> 'p'; 42 ~> 'q'; 43 ~> 'r'; 44 ~> 's'; 45 ~> 't'; 46 ~> 'u'; 47 ~> 'v'; 48 ~> 'w'; 49 ~> 'x'; 50 ~> 'y'; 51 ~> 'z'; 52 ~> '0'; 53 ~> '1'; 54 ~> '2'; 55 ~> '3'; 56 ~> '4'; 57 ~> '5'; 58 ~> '6'; 59 ~> '7'; 60 ~> '8'; 61 ~> '9'; 62 ~> '+'; 63 ~> '/'; 64 ~> '=' ... 65 ... |]
9 ==> System.DBNull CLASS []
10 ==> [| 0 ~> 1; 1 ~> 10; 2 ~> 100; 3 ~> 1000; 4 ~> 10000; 5 ~> 100000; 6 ~> 1000000; 7 ~> 10000000; 8 ~> 100000000; 9 ~> 1000000000; 10 ~> 10000000000; 11 ~> 100000000000; 12 ~> 1000000000000; 13 ~> 10000000000000; 14 ~> 100000000000000; 15 ~> 1E+15 ... 16 ... |]
---------- s1 = ----------
EmptyArray`1[System.Type] ==> CLASS [
	| Value ~> UNION[
		| !hasKey#1 & !hasKey#2 & !hasKey#6 ~> (HeapRef 7)
		| hasKey#1 | hasKey#2 | hasKey#6 ~> (HeapRef EmptyArray`1[System.Type].Value)]]
System.Convert ==> CLASS [
	| ConvertTypes ~> UNION[
		| !hasKey#1 ~> (HeapRef 1)
		| hasKey#1 ~> (HeapRef System.Convert.ConvertTypes)]
	| DBNull ~> UNION[
		| !hasKey#1 & !hasKey#8 ~> (HeapRef 9)
		| !hasKey#1 & hasKey#8 ~> (HeapRef System.DBNull.Value)
		| hasKey#1 ~> (HeapRef System.Convert.DBNull)]
	| EnumType ~> UNION[
		| !hasKey#1 ~> System.Enum
		| hasKey#1 ~> (HeapRef System.Convert.EnumType)]
	| base64LineBreakPosition ~> UNION[
		| !hasKey#1 ~> 76
		| hasKey#1 ~> System.Convert.base64LineBreakPosition]
	| base64Table ~> UNION[
		| !hasKey#1 ~> (HeapRef 8)
		| hasKey#1 ~> (HeapRef System.Convert.base64Table)]]
System.DBNull ==> CLASS [
	| Value ~> UNION[
		| !hasKey#1 & !hasKey#8 ~> (HeapRef 9)
		| hasKey#1 | hasKey#8 ~> (HeapRef System.DBNull.Value)]]
System.Math ==> CLASS [
	| E ~> UNION[
		| !hasKey#9 ~> 2.71828182845905
		| hasKey#9 ~> System.Math.E]
	| PI ~> UNION[
		| !hasKey#9 ~> 3.14159265358979
		| hasKey#9 ~> System.Math.PI]
	| doubleRoundLimit ~> UNION[
		| !hasKey#9 ~> 1E+16
		| hasKey#9 ~> System.Math.doubleRoundLimit]
	| maxRoundingDigits ~> UNION[
		| !hasKey#9 ~> 15
		| hasKey#9 ~> System.Math.maxRoundingDigits]
	| roundPower10Double ~> UNION[
		| !hasKey#9 ~> (HeapRef 10)
		| hasKey#9 ~> (HeapRef System.Math.roundPower10Double)]]
System.Object ==> CLASS []
System.Reflection.Missing ==> CLASS [
	| Value ~> UNION[
		| !hasKey#1 & !hasKey#2 & !hasKey#5 ~> (HeapRef 6)
		| hasKey#1 | hasKey#2 | hasKey#5 ~> (HeapRef System.Reflection.Missing.Value)]]
System.Runtime.CompilerServices.RuntimeHelpers ==> CLASS []
System.Type ==> CLASS [
	| DeclaredOnlyLookup ~> UNION[
		| !hasKey#1 & !hasKey#2 ~> DeclaredOnly, Instance, Static, Public, NonPublic
		| hasKey#1 | hasKey#2 ~> System.Type.DeclaredOnlyLookup]
	| DefaultLookup ~> UNION[
		| !hasKey#1 & !hasKey#2 ~> Instance, Static, Public
		| hasKey#1 | hasKey#2 ~> System.Type.DefaultLookup]
	| Delimiter ~> UNION[
		| !hasKey#1 & !hasKey#2 ~> 46
		| hasKey#1 | hasKey#2 ~> System.Type.Delimiter]
	| EmptyTypes ~> UNION[
		| !hasKey#1 & !hasKey#2 & !hasKey#6 ~> (HeapRef 7)
		| !hasKey#1 & !hasKey#2 & hasKey#6 ~> (HeapRef EmptyArray`1[System.Type].Value)
		| hasKey#1 | hasKey#2 ~> (HeapRef System.Type.EmptyTypes)]
	| FilterAttribute ~> UNION[
		| !hasKey#1 & !hasKey#2 ~> (HeapRef 3)
		| hasKey#1 | hasKey#2 ~> (HeapRef System.Type.FilterAttribute)]
	| FilterName ~> UNION[
		| !hasKey#1 & !hasKey#2 ~> (HeapRef 4)
		| hasKey#1 | hasKey#2 ~> (HeapRef System.Type.FilterName)]
	| FilterNameIgnoreCase ~> UNION[
		| !hasKey#1 & !hasKey#2 ~> (HeapRef 5)
		| hasKey#1 | hasKey#2 ~> (HeapRef System.Type.FilterNameIgnoreCase)]
	| Missing ~> UNION[
		| !hasKey#1 & !hasKey#2 & !hasKey#5 ~> (HeapRef 6)
		| !hasKey#1 & !hasKey#2 & hasKey#5 ~> (HeapRef System.Reflection.Missing.Value)
		| hasKey#1 | hasKey#2 ~> (HeapRef System.Type.Missing)]
	| defaultBinder ~> UNION[
		| !hasKey#1 & !hasKey#2 ~> null
		| hasKey#1 | hasKey#2 ~> (HeapRef System.Type.defaultBinder)]]
System.__Filters ==> CLASS [
	| Instance ~> UNION[
		| !hasKey#1 & !hasKey#2 & !hasKey#3 ~> (HeapRef 2)
		| hasKey#1 | hasKey#2 | hasKey#3 ~> (HeapRef System.__Filters.Instance)]]
VSharp.Test.Tests.Arithmetics ==> CLASS []
