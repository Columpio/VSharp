METHOD: System.Double VSharp.Test.Tests.Typecast.Helper.CastStructToInterface(VSharp.Test.Tests.Typecast.Coord)
RESULT: sqrt((System.Double)(arg.VSharp::Test::Tests::Typecast::Coord::X * arg.VSharp::Test::Tests::Typecast::Coord::X + arg.VSharp::Test::Tests::Typecast::Coord::Y * arg.VSharp::Test::Tests::Typecast::Coord::Y))
HEAP:
{ heap = h0, statics = s1 } where
---------- h0 = ----------
1 ==> VSharp.Test.Tests.Typecast.Coord STRUCT [
	| VSharp::Test::Tests::Typecast::Coord::X ~> arg.VSharp::Test::Tests::Typecast::Coord::X
	| VSharp::Test::Tests::Typecast::Coord::Y ~> arg.VSharp::Test::Tests::Typecast::Coord::Y]
2 ==> [| 0 ~> 1; 1 ~> 10; 2 ~> 100; 3 ~> 1000; 4 ~> 10000; 5 ~> 100000; 6 ~> 1000000; 7 ~> 10000000; 8 ~> 100000000; 9 ~> 1000000000; 10 ~> 10000000000; 11 ~> 100000000000; 12 ~> 1000000000000; 13 ~> 10000000000000; 14 ~> 100000000000000; 15 ~> 1E+15 ... 16 ... |]
---------- s1 = ----------
System.Math ==> CLASS [
	| E ~> UNION[
		| !hasKey#3 ~> 2.71828182845905
		| hasKey#3 ~> System.Math.E]
	| PI ~> UNION[
		| !hasKey#3 ~> 3.14159265358979
		| hasKey#3 ~> System.Math.PI]
	| doubleRoundLimit ~> UNION[
		| !hasKey#3 ~> 1E+16
		| hasKey#3 ~> System.Math.doubleRoundLimit]
	| maxRoundingDigits ~> UNION[
		| !hasKey#3 ~> 15
		| hasKey#3 ~> System.Math.maxRoundingDigits]
	| roundPower10Double ~> UNION[
		| !hasKey#3 ~> (HeapRef 2)
		| hasKey#3 ~> (HeapRef System.Math.roundPower10Double)]]
System.Runtime.CompilerServices.RuntimeHelpers ==> CLASS []
VSharp.Test.Tests.Typecast.Coord ==> VSharp.Test.Tests.Typecast.Coord STRUCT []
VSharp.Test.Tests.Typecast.Helper ==> CLASS []
VSharp.Test.Tests.Typecast.INormalize ==> CLASS []
